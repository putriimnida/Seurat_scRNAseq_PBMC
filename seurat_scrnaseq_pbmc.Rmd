---
title: "PBMC scRNA-seq analysis"
author: "Putri Ramadani"
date: "2025-05-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

This notebook follows the [Seurat PBMC 3K tutorial](https://satijalab.org/seurat/articles/pbmc3k_tutorial) to analyze \~3,000 peripheral blood mononuclear cells using single-cell RNA-seq data from 10X Genomics.

**Goal**: learn how to perform quality control, clustering, and visualization using Seurat v5

# Setup the Seurat Object

```{r setup, message=FALSE, warning=FALSE}
library(dplyr)
library(Seurat)
library(patchwork)
library(ggrepel)
library(ggplot2)

# Load the PBMC dataset
pbmc.data <- Read10X(data.dir = "data/filtered_gene_bc_matrices/hg19/")
# Initialize the Seurat object with the raw (non-normalized data).
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
pbmc


# --- output --- #
# An object of class Seurat 
# 13714 features across 2700 samples within 1 assay 
# Active assay: RNA (13714 features, 0 variable features)
# 1 layer present: counts
# ------------- #
```

## Optional for learning
### Let's examine a few genes in the first thirty cells

```{r}
pbmc.data[c("CD3D", "TCL1A", "MS4A1"), 1:30]

# -- output -- #
# 3 x 30 sparse Matrix of class "dgCMatrix"
#  [[ suppressing 30 column names ‘AAACATACAACCAC-1’, ‘AAACATTGAGCTAC-1’, ‘AAACATTGATCAGC-1’ ... ]]
                                                                   
# CD3D  4 . 10 . . 1 2 3 1 . . 2 7 1 . . 1 3 . 2  3 . . . . . 3 4 1 5
# TCL1A . .  . . . . . . 1 . . . . . . . . . . .  . 1 . . . . . . . .
# MS4A1 . 6  . . . . . . 1 1 1 . . . . . . . . . 36 1 2 . . 2 . . . .
```

The . values in the matrix represent 0s (no molecules detected). Since most values in an scRNA-seq matrix are 0, Seurat uses a sparse-matrix representation whenever possible. This results in significant memory and speed savings for Drop-seq/inDrop/10x data.

```{r}
dense.size <- object.size(as.matrix(pbmc.data))
dense.size

# -- output -- #
# 709591472 bytes

# dense matrix:
# Every element (including 0s) is stored, memory grows quickly with matrix size, wastes memory on zeros
```

```{r}
sparse.size <- object.size(pbmc.data)
sparse.size

# -- output -- #
# 29905192 bytes
# sparse matrix only stores non-zero enries, greatly redoces size and improves speed
```

```{r}
dense.size/sparse.size
# -- output -- #
# 23.7 bytes
# meaning the dense version of your matrix would use ~23.7 times more memory than the sparse version.
```

# Standard pre-processing workflow

The steps below encompass the standard pre-processing workflow for scRNA-seq data in Seurat. These represent the selection and filtration of cells based on QC metrics, data normalization and scaling, and the detection of highly variable features.

# QC and selecting cells for further analysis
Seurat allows you to easily explore QC metrics and filter cells based on any user-defined criteria. A few QC metrics commonly used by the community include:

- The number of unique genes detected in each cell.
Low-quality cells or empty droplets will often have very few genes
Cell doublets or multiplets may exhibit an aberrantly high gene count

- Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes)

- The percentage of reads that map to the mitochondrial genome
Low-quality / dying cells often exhibit extensive mitochondrial contamination
We calculate mitochondrial QC metrics with the PercentageFeatureSet() function, which calculates the percentage of counts originating from a set of features
We use the set of all genes starting with MT- as a set of mitochondrial genes
```{r}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
head(pbmc)
```

## optional for learning: where are QC metrics stored in Seurat?
The number of unique genes and total molecules are automatically calculated during CreateSeuratObject()
You can find them stored in the object meta data
```{r}
# Show QC metrics for the first 5 cells
head(pbmc@meta.data, 5)

```
In the example below, we visualize QC metrics, and use these to filter cells.
- we filter cells that have unique feature counts over 2,500 or less than 200
- we filter cells that have >5% mitocrondrial counts
```{r}
# visualize QC metrics as a violin plot
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```
What is a violin plot?
a violin plot combines:
- a boxplot (shows median, interquartile range)
- a kernel density plot (shows distribution shape)
so the wider the violin, the more cells have values in that range.

How to read each plot:
1. nFeature_RNA = number of detected genes per cell
X-axis: dataset (here only "pbmc3k)
Y-axis: number of genes
Interpretation:
- most cells have ~500-2000 genes detected
- some cells have <200 genes (likely poor quality or empty droplets)
- some cells have >2,500, which could indicate multiplets (doublets)
Filtering rule: Keep cells with 200-2,500 features

2. nCount_RNA = total counts per cell (UMI counts)
- reflects total RNA captured
- high counts with high nFeature_RNA = good
- high counts but low gene diversity may indicate noisy cells

3. percent.mt = % of reads mapping to mitochondrial genes
- high values(>5%) suggest stressed or dying cells
- most cells have ~0-5%, good!
- you may want to remove cells with >5%


```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```
This plot uses FeatureScatter() to visualize relationships between QC metrics across cells. Here’s how to interpret the two scatter plots:

1. nCount_RNA vs percent.mt
X-axis: total UMI counts per cell
Y-axis: % mitochondrial gene expression
Interpretation:
- most cells cluster below 5% mitochondrial content, as expected.
- some cells with high total counts also show high mitochondrial percentages -> could be dying or stressed cells.
- weak correlation (-0.13): there's no. strong relationship between total RNA and mitochondrial %.

This supports the use of percent.mt < 5 as a filtering threshold to exclude low-quality cells.


2. nCount_RNA vs nFeature_RNA
X-axis: total counts
Y-axis: number of detected genes
Interpretation:
- strong positive correlation (0.95): more total RNA -> more genes detected.
- however, some outliers have high total RNA but relatively low gene counts, suggesting:
a. Ambient RNA (free-floating RNA molecules present in the cell suspension or droplets during single-cell RNA-seq experiments, not coming from inside a cell, can be from broken or lysed cells, cell debris, or dead cells).

Why is ambient RNA a problem?
It introduces false positive gene expression.
It may inflate UMI counts without increasing gene diversity.
It causes contamination — e.g., mitochondrial RNA in non-mitochondrial cells.

How to spot it?
Cells with high nCount_RNA but low nFeature_RNA (many reads but few genes).
"Empty" droplets with detectable RNA.

Tools to correct for ambient RNA:
- Seurat filters some contaminated cells via QC thresholds.
- SoupX, CellBender, and DecontX are specialized tools to identify and remove ambient RNA contamination.

b. Doublets
c. Over-sequencing of few transcripts

This justifies filtering cells with too few or too many genes:
nFeature_RNA > 200 & < 2500


Filtering:
```{r}
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
pbmc
```
This keeps cells that:
- Have enough genes to be valid
- Are not doublets
- Are not stressed or dying


# Normalizing the data
After removing unwanted cells from the dataset, the next step is to normalize the data. By default, we employ a global-scaling normalization method “LogNormalize” that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. In Seurat v5, Normalized values are stored in pbmc[["RNA"]]$data.
```{r}
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
```
For clarity, in this previous line of code (and in future commands), we provide the default values for certain parameters in the function call. However, this isn’t required and the same behavior can be achieved with:
```{r}
pbmc <- NormalizeData(pbmc)
```
While this method of normalization is standard and widely used in scRNA-seq analysis, global-scaling relies on an assumption that each cell originally contains the same number of RNA molecules. 

SCTransform() normalization workflow is developed for alternative workflows for the single cell preprocessing that do not make these assumptions. The use of SCTransform replaces the need to run NormalizeData, FindVariableFeatures, or ScaleData (described below.)

Note:
If you're doing real research, especially with noisy, clinical, or large datasets → use SCTransform().
If you're just learning or following tutorials like PBMC3K → NormalizeData() is fine and easier to follow.

Check SCTransform: https://satijalab.org/seurat/articles/sctransform_vignette 


# Identification of highly variable features (feature selection)
We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets.

Procedure in Seurat is described in detail here (Check their paper), and improves on previous versions by directly modeling the mean-variance relationship inherent in single-cell data, and is implemented in the FindVariableFeatures() function. By default, we return 2,000 features per dataset. These will be used in downstream analysis, like PCA.


```{r}
# Note: This code chunk from Seurat v5 website couldn't result clear-spaced graph

pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
```
This VariableFeaturePlot is visualizing how much each gene varies across cells in your single-cell dataset.
- Each dot = one gene
- X-axis = Average expression (log scale)
- Y-axis = Standardized variance (how much a gene's expression varies across cells)
goal: To identify genes with the highest cell-to-cell variability, which are the most informative for downstream steps like PCA and clustering.

Red dots:
- These are the 2,000 most variable genes, selected using Seurat’s FindVariableFeatures() function
- They're the ones that vary the most across cells, often because they’re cell-type-specific or biologically important.

Black dots:
- These are the rest (~11,714) — less variable genes
- They’re filtered out of downstream steps like PCA (to reduce noise)

Labeled top 10 genes
These are the most variable genes, likely key markers in your dataset.
Examples from the plot:
PPBP: typically expressed in platelets
LYZ: marker of monocytes
GNLY, NKG7: markers for NK and cytotoxic T cells
S100A9, FTL: immune response and inflammation

These can hint at the types of immune cells in your PBMC sample!


```{r}
# Alternative (repaired pipeline by Putri)

# Load necessary library
library(ggplot2)
library(ggrepel)

# Extract variable gene data
var.genes <- HVFInfo(pbmc)
var.genes$gene <- rownames(var.genes)
var.genes$top10 <- var.genes$gene %in% head(VariableFeatures(pbmc), 10)

# Plot manually
ggplot(var.genes, aes(x = mean, y = variance.standardized)) +
  geom_point(aes(color = top10), alpha = 0.7, size = 1.2) +
  geom_text_repel(
    data = subset(var.genes, top10),
    aes(label = gene),
    size = 3.5,
    max.overlaps = 100,
    box.padding = 0.5,
    segment.color = "grey50"
  ) +
  scale_color_manual(values = c("black", "red")) +
  theme_minimal(base_size = 14) +
  labs(
    title = "Highly Variable Genes",
    x = "Average Expression",
    y = "Standardized Variance",
    color = NULL
  )

```
Summary note: The plot highlights the 2,000 most variable genes (in red), which are selected for dimensionality reduction and clustering. Genes such as PPBP, LYZ, and GNLY appear among the top 10, indicating potential cell type–specific expression. Highly variable genes are essential for capturing meaningful biological variation across cells in single-cell RNA-seq analysis.


# Scaling the data
Next, we apply a linear transformation (‘scaling’) that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData() function:
- Shifts the expression of each gene, so that the mean expression across cells is 0
- Scales the expression of each gene, so that the variance across cells is 1. This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate
- The results of this are stored in pbmc[["RNA"]]$scale.data
- By default, only variable features are scaled.
- You can specify the features argument to scale additional features
```{r}
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes)
```

## How can I remove unwanted sources of variation?
In Seurat, we also use the ScaleData() function to remove unwanted sources of variation from a single-cell dataset. For example, we could ‘regress out’ heterogeneity associated with (for example) cell cycle stage, or mitochondrial contamination i.e.:
```{r}
pbmc <- ScaleData(pbmc, vars.to.regress = "percent.mt")
```
However, particularly for advanced users who would like to use this functionality, we strongly recommend the use of our new normalization workflow, SCTransform(). The method is described in our paper, with a separate vignette using Seurat here. As with ScaleData(), the function SCTransform() also includes a vars.to.regress parameter. -Satija Lab


# Perform linear dimensional reduction









